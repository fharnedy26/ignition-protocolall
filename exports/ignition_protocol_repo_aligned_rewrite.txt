Ignition Protocol
An Evolutionary Engine for Molecular Combustion
Stripe Young Scientist & Technology Exhibition 2026

by Finn Harnedy


1. Abstract

Ignition Protocol is a computational framework for discovering, filtering, and operationalising synthetic fuel candidates. In the current implementation, the system is a unified pipeline with two coupled engines:

(1) a molecular generation module that evolves candidate molecules from fragment libraries using RDKit-based validity checks and a multi-objective fitness score, and
(2) a deterministic blend optimisation engine that selects and proportions real components (including optional “novel” candidates) into lab-ready fuel blends subject to fuel-type specifications.

The molecular generator produces candidate SMILES strings and attaches practical metadata (estimated fuel properties, synthesis feasibility and a suggested synthesis route, plus simple storage-stability proxies). The blend optimiser converts a component library into an optimised recipe (volume fractions, mL and grams per 1000 mL) while enforcing constraints such as volatility limits (T10/T90, RVP), minimum octane/cetane requirements, density bounds (diesel/jet), and caps on each component’s maximum volume fraction.

The project is designed to bridge computational fuel design with proposed experimental validation: combustion “fingerprinting” (flame imaging and spectroscopy) and environmental stability assays (storage stability and biodegradability screening). Where experimental procedures are described in this manuscript, they are presented as a planned validation framework unless explicitly accompanied by datasets and analysis scripts.


2. Introduction

Synthetic fuels and fuel blends offer a path to reducing reliance on fossil energy while meeting global demand and tightening emissions constraints. Traditional formulation approaches often revolve around modifying known components, which limits exploration of the much larger chemical space of fuel-like molecules.

Ignition Protocol addresses this by combining:

- broad exploration (a fragment-based evolutionary generator that proposes fuel-like molecules), and
- operational realism (a deterministic blend optimiser that respects real fuel constraints and outputs lab-ready mixing recipes).

In other words, the project is not just about ranking "interesting molecules"; it is about producing candidate blends that can be mixed, tested, and iterated upon with clear reproducibility.

2.1 System Evolution: From Basic Engine to Unified Pipeline

The current Ignition Protocol repository represents a significant evolution from an initial "basic engine" prototype. Understanding this progression helps contextualize the system's capabilities and design decisions.

The Basic Engine (Initial Prototype)

The foundational version of Ignition Protocol was a computational benchmarking tool focused on molecular generation efficiency. Its architecture followed a simple pipeline:

BRICS Seeding → Mutation → Filtering → Scoring

The engine initialized with seed molecules using BRICS (Breaking of Retrosynthetically Interesting Chemical Substructures), a fragment-based method that breaks known molecules into chemically sensible fragments and allows recombination. At each generation, fragments were attached or substituted according to BRICS rules, creating new candidate molecules through combinatorial growth.

After each generation, candidates passed through heuristic filters that enforced:
- Chemical validity (no valence violations, reasonable sizes)
- Fuel-relevance (C/H/O content, carbon number ranges, exclusion of exotic elements)
- Property thresholds (screening out highly polar molecules or excessive aromatic content)

Survivors were then scored using surrogate models—fast algebraic formulas and lightweight QSAR-like estimates for properties such as cetane number, octane rating, and enthalpy of vaporization. These were combined into a composite "ignition performance score" that the engine maximized.

The basic engine was benchmarked across six workload profiles:
- Ultra-snappy: ~30-40 candidates, 1-2 seconds
- Demo: ~200-250 candidates, 6-8 seconds
- Classroom: ~3,000-5,000 candidates, 45-60 seconds
- Light Stress: ~50,000 candidates, 3.7-5 minutes
- Heavy Stress: ~180,000-200,000 candidates, 15-20 minutes
- Brutal: ~800,000 candidates, 45-60 minutes

These profiles demonstrated that the engine could efficiently process large numbers of candidates using fast heuristic filtering and simple scoring, with runtime scaling roughly linearly with candidate count.

Evolution to Current System

The current repository represents a major architectural shift from a pure molecular generation tool to a unified fuel design pipeline:

1. Enhanced Molecular Generation: The fragment-based evolution remains, but now integrates:
   - Synthesis feasibility assessment (home-synthesis mode with curated fragment libraries)
   - Practical metadata attachment (synthesis routes, oxidation susceptibility, phase separation risk)
   - Bridge to blend optimization (molecule_to_component conversion)

2. New Blend Optimization Engine: A completely new deterministic optimization module that:
   - Accepts component library CSVs (established fuels + optional novel candidates)
   - Enforces fuel-type specifications (gasoline/diesel/jet constraints)
   - Produces lab-ready recipes (volume fractions, mL and grams per 1000 mL)
   - Supports multiple optimization themes (high RON, low PMI, high LHV, low cost)
   - Generates reproducible outputs with complete metadata (RUN.json)

3. Unified Workflow: The system now bridges molecular discovery to practical formulation:
   - Molecular generator produces candidate SMILES
   - Conversion module estimates fuel properties and creates component records
   - Blend optimizer selects and proportions components into spec-compliant blends
   - Outputs are immediately actionable for laboratory mixing and testing

4. Reproducibility Focus: Unlike the basic engine's benchmarking emphasis, the current system prioritizes:
   - Deterministic optimization (same seed → same results)
   - Complete parameter capture (RUN.json with all settings)
   - Structured CSV outputs (Top-N blends, Portfolio diversity analysis)
   - Clear traceability from fragments to final blend recipes

Key Design Improvements

The evolution addressed several limitations of the basic engine:

- Operational Realism: The basic engine optimized molecules in isolation; the current system optimizes realistic blends under real-world constraints (volatility limits, octane requirements, component caps).

- Practical Integration: Novel molecules are no longer just ranked candidates; they are converted to blend-compatible component records and can be incorporated into optimized fuel formulations.

- Reproducibility: The basic engine was designed for performance testing; the current system is designed for reproducible experimental workflows where the same inputs must produce identical outputs.

- End-to-End Pipeline: The basic engine stopped at molecular generation; the current system extends through blend formulation to lab-ready recipes.

This progression reflects a shift from "can we generate many candidates quickly?" to "can we produce actionable fuel formulations that can be tested and iterated upon?" The current repository maintains the computational efficiency of the basic engine while adding the operational realism needed for practical fuel design.


3. Literature Review (condensed, with focus on what the engine encodes)

This project is grounded in three bodies of knowledge:

3.1 Combustion fundamentals and fuel performance metrics
Fuel behaviour depends on stoichiometry, ignition chemistry, volatility, and flame propagation. Key operational metrics include octane number (RON/MON) for spark-ignition fuels, cetane number for compression-ignition fuels, energy density (LHV), and sooting tendency proxies (PMI/TSI). These metrics motivate the “objective functions” used in computational scoring and the blend constraints used in optimisation.

3.2 Emissions and regulatory constraints
Modern fuels are constrained by emissions drivers (NOx, soot/PM, CO, UHC), infrastructure compatibility, and regulations (e.g., volatility limits, sulfur limits, density/flashpoint constraints, and seasonal RVP management). A realistic fuel design system must treat these as constraints, not afterthoughts.

3.3 AI / evolutionary search for molecular design
Evolutionary computation has a long history in molecular design (genetic algorithms, mutation/crossover operators, multi-objective optimisation). Modern approaches also integrate surrogate models, including ML predictors, to accelerate screening. Ignition Protocol currently uses lightweight structural heuristics and fast property proxies to keep per-candidate evaluation cheap, while leaving a clear pathway to later ML integration (e.g., hierarchical filtering followed by GPU-accelerated models).


4. Implemented System Architecture (as in the current repository)

This section describes the system architecture that is implemented in the current project repository, not an aspirational design.

4.1 Major modules

A) Molecular generation: molecular_generator/
- generator.py
  - evolve_with_fragments(): fragment-based evolution loop
  - evolve_home_synthesizable_molecules(): evolution with synthesis feasibility constraints
- fitness.py
  - compute_fuel_fitness_v3(): fast fuel-likeness / performance proxy score
  - estimate_synthesis_feasibility(): home-synthesis feasibility + complexity score
  - estimate_oxidation_susceptibility(), estimate_phase_separation_risk(), estimate_ph_change()
- molecule_to_component.py
  - molecule_to_component(): convert SMILES into a component row for blend optimisation
  - estimate_fuel_properties(): heuristics for RON/MON/cetane/LHV/PMI/TSI/density/T10/T50/T90/RVP
- synthesis.py and home_synthesis_fragments.py
  - suggest_synthesis_route(): classify reaction type and provide basic route metadata
  - curated home-synthesis fragment lists and checks

B) Blend optimisation: fuel_engine/
- optimization.py
  - greedy_then_refine(): deterministic optimiser (greedy selection + refinement) with constraints
- properties.py
  - blend_props(): fast property aggregation for candidate blends (RON/MON/cetane/LHV/PMI/TSI/OC_ratio/ring_count/T10/T50/T90/RVP/cost)
- io.py
  - write_top_n_csv(), write_portfolio_csv(), write_run_json(): outputs
- constants.py
  - SPECS: fuel-type limits (gasoline/diesel/jet), scoring weights, penalty multipliers

C) CLI orchestration: engine.py
The CLI is the practical “engine entry point” for blend optimisation: it loads component CSVs, applies presets, runs optimisation across restarts/themes, and writes outputs to runs/<timestamp>_<seed>/.

4.2 Data flow (end-to-end)

The implemented pipeline looks like this:

Fragments (SMILES)  -->  Molecular generator (GA)  -->  Candidate SMILES
     |                                                      |
     |                                                      v
     +---------------------------------->  molecule_to_component  -->  Novel component CSV
                                                            |
                                                            v
Component library CSV (+ optional novel CSV)  -->  Blend optimiser (engine.py)  -->  Top-N blends + lab recipes + RUN metadata

4.3 Determinism and reproducible outputs

The blend optimisation engine is designed to be reproducible. Runs are parameterised by a seed and a complete argument set stored in RUN.json. Outputs are written as CSVs with explicit blend compositions and computed properties.


5. Reproducibility (how to run the implemented engine)

5.1 Environment

- Install dependencies:
  pip install -r requirements.txt

Notes:
- GPU acceleration is optional and primarily relevant for future extensions. The current deterministic optimiser already runs quickly on CPU, and the molecular generator is also CPU-oriented.

5.2 Blend optimisation (recommended “core demo”)

Basic optimisation:
  python engine.py --components components.csv --fuel-type gasoline --K 5 --top 15 --seed 42

Allow novel components:
  python engine.py --components components.csv --novel components_novel.csv --allow-novel 1 --max-add-novel 0.03 --fuel-type gasoline --K 5 --top 10

Delta mode around a baseline blend:
  python engine.py --components components.csv --baseline baseline_blend.csv --fuel-type gasoline --preset delta --delta-budget 0.05 --top 10

Outputs:
- runs/<timestamp>_<seed>/Top-N.csv
- runs/<timestamp>_<seed>/Portfolio.csv
- runs/<timestamp>_<seed>/RUN.json

5.3 Molecular generation (script/notebook workflow)

Conceptual workflow:
- Load fragments from a text file
- Run evolve_with_fragments() (or evolve_home_synthesizable_molecules())
- Convert top candidates to a “novel components” CSV using molecules_to_component_csv()
- Optimise blends with engine.py

The project includes a unified notebook demonstrating the pipeline:
  notebooks/unified_workflow.ipynb


6. Methodology (updated to match current implementation)

This project integrates computational design (implemented) with an experimental validation framework (planned unless accompanied by datasets).

6.1 Fragment preparation and cleaning (implemented tooling; dataset is user-provided)

The system expects fragment libraries as flat-text SMILES files (optionally gzipped). The repository provides utilities to:

- Load fragments: molecular_generator/fragments.py: load_fragments()
- Clean fragments with RDKit sanitation and a “must contain carbon” rule: clean_fragment_list()

In earlier drafts of the project, I described scaling to extremely large fragment pools derived from GDB-17. The current repository is designed to support that workflow, but the large raw datasets themselves are not bundled here. In practice, fragment size is an experimental lever: small curated sets are ideal for demos; larger sets are used for deeper exploration when data is available.

6.2 Evolutionary generator and molecular construction (implemented)

The current molecular generator is a fragment-based evolutionary loop with simple operators:

- Initialisation: build an initial population by combining fragment pairs and filtering for validity and allowed atoms (C/H/O by default).
- Selection: keep the top “survivors” by fitness.
- Crossover: combine two survivor molecules (or fragments) into a new candidate.
- Mutation: optionally apply small random SMILES perturbations (used in the simpler evolve_population pathway).

Important implementation note:
This repository’s “merge” operator uses RDKit CombineMols and sanitation. It is a pragmatic, fast composition operator, not a full BRICS recombination pipeline. The text in earlier versions that described BRICS specifically should be interpreted as a conceptual inspiration / future enhancement path, not as the behaviour of the current codebase.

6.3 Fitness evaluation (implemented)

Ignition Protocol uses fast structural proxies as a first-pass scoring mechanism. The current primary molecule fitness (compute_fuel_fitness_v3) is driven by:

- Molecular weight targeting (~150)
- logP targeting (~1.5)
- O/C ratio targeting (~0.2)
- Penalising hydrogen bond donors
- Penalising ring count

This yields a cheap score suitable for iterating over many candidates quickly.

Home synthesis extensions (implemented in this repository) add:
- Synthesis feasibility score (0–100) + complexity rating (1–10)
- Suggested synthesis route metadata (reaction type, difficulty, yield estimate)
- Oxidation susceptibility proxy (0–10)

These are used to bias evolution toward candidates that are more practically synthesizable and testable.

6.4 Bridging molecules to blend components (implemented)

The bridge module converts SMILES into component rows compatible with the blend optimiser. For each molecule, it estimates:

- RON/MON/cetane
- LHV (MJ/kg), density, PMI/TSI
- Volatility proxies (T10/T50/T90, RVP)

and emits a component record including max volume fraction caps and (optionally) waste-credit economics for novel components.

This step is explicitly a surrogate layer: the estimates are fast heuristics intended for ranking and screening, not definitive ASTM-grade property predictions.

6.5 Deterministic blend optimisation (implemented)

The blend optimiser:
- Accepts a component library CSV and optional novel components CSV
- Enforces fuel-type constraints using SPECS (gasoline/diesel/jet)
- Supports strict feasibility (reject blends violating specs) and soft penalties
- Supports delta mode around a baseline (L1 budget)
- Supports caps on each component’s maximum volume fraction (max_vol_frac)
- Produces Top-N blends and a “portfolio” of diverse solutions

6.6 Planned experimental validation (planned protocols)

Combustion fingerprinting (planned):
- Consistent burner setup
- Flame imaging (RGB video, long exposure)
- Spectral collection (400–700 nm)
- Feature extraction (colour histograms, flicker FFT, peak detection)
- PCA/cluster visualisation for “fingerprint” separation

Environmental stability and biodegradability screening (planned):
- Simple storage stability checks (phase separation, pH change)
- Soil slurry biodegradability observations (biofilm, odour, pH)

These protocols are presented as a structured validation plan. The current repository focuses on computational design and produces the candidate lists and blend recipes required to execute the experiments reproducibly.


7. Benchmark Profiles and Setup (kept; updated to match the repo)

This section retains the “profiles” concept because it is useful for communicating scalability and for live demonstrations. However, in the current repository, profiles are best understood as parameter presets for the implemented generator functions (evolve_with_fragments / evolve_home_synthesizable_molecules), not as a separate BRICS-specific engine mode.

Each profile can be expressed primarily using:
- generations
- population_size
- survivors
- n_frags_per_molecule
- (optional) min_feasibility and synthesis weighting (home-synthesis mode)

Ultra-snappy Profile (instant feedback / smoke test)
- generations: 1–2
- population_size: ~20–40
- survivors: ~5–10
- n_frags_per_molecule: 2
Goal: produce a small handful of candidates quickly to verify the pipeline.

Demo Profile (live demonstration)
- generations: ~5–10
- population_size: ~50
- survivors: ~10
- n_frags_per_molecule: 2–3
Goal: show visible improvement of the top candidate over several iterations.

Classroom Profile (interactive lab session)
- generations: ~20–50
- population_size: ~50–100
- survivors: ~10–20
- n_frags_per_molecule: 3
Goal: demonstrate a meaningful exploration while still finishing within a practical teaching window.

Light Stress Profile (deliberate scaling test)
- generations: ~100
- population_size: ~100–200
- survivors: ~20–40
- n_frags_per_molecule: 3

Heavy Stress Profile (upper desktop scale)
- generations: ~200–500
- population_size: ~200+
- survivors: ~40+
- n_frags_per_molecule: 3–4

Brutal Profile (edge-of-feasibility exploration)
- generations: 500–1000+
- population_size: 200–500+
- survivors: 50–100+
- n_frags_per_molecule: 3–4

Important note on candidate counts:
In the implemented generator, the total number of attempted constructions depends on internal attempt caps (population_size * 10 per generation in the current code paths) and on how often candidates pass validity + fuel filters. Therefore, “candidate counts” should be reported as:
- attempted constructions,
- valid unique candidates accepted, and
- candidates scored,
rather than only a single headline number.

If you include timing benchmarks, label them clearly as “measured on system X, with fragment file Y and parameters Z,” because both fragment libraries and validity rates change runtime substantially.


8. Results and Preliminary Outputs (updated to reflect repo artefacts)

This section presents results from both the basic engine prototype and the current unified system, demonstrating the progression from molecular generation benchmarking to practical blend formulation.

8.1 Basic Engine Results (Initial Prototype)

The foundational version of Ignition Protocol focused on demonstrating that fragment-based evolutionary generation could efficiently explore fuel-relevant chemical space. Results from early runs illustrate the engine's ability to evolve molecules toward fuel-like properties.

8.1.1 Starting Molecule Pool and Fragment Diversity

The evolutionary engine was initialized with a set of ten simple, oxygenated base molecules. These included short-chain alcohols, ethers, esters, and alkenyl alcohols, chosen for their fuel relevance and structural simplicity. These fragments served as building blocks for larger, more complex molecules in the generator. The selection aimed to capture a range of functional groups known to influence combustion, volatility, and biodegradability. Their presence promoted diversity in the resulting molecular structures and supported chemically reasonable crossover and mutation operations in the generator.

8.1.2 Evolved Molecules After 20 Generations

Following twenty generations of crossover, mutation, and fitness-based selection, the population exhibited clear growth in structural complexity. Saturated and unsaturated hydrocarbon chains combined with the original oxygenated motifs to yield esters, ethers, and alkenyl esters with one or two rings. Key observations from generation 20:

- Median molecular weight rose to 128 g mol⁻¹ (from lower initial values)
- Mean oxygen-to-carbon ratio climbed from 0.10 to 0.12
- Ring count distribution remained centered on one, demonstrating that the ring-penalty component of the fitness function prevented runaway aromaticity
- Many generation-20 molecules fell within the desired window for spark-ignition fuels: logP 2–4, molecular weight 110–150 g mol⁻¹, and zero halogens

These observations showed that the early evolutionary pressure successfully moved the population toward fuel-relevant regions of chemical space without sacrificing chemical validity.

8.1.3 Fitness Progression Across Generations

The progression of the highest fitness score across the first twenty generations is shown in graph 7.1.3. The graph illustrates a typical evolutionary optimization pattern:

- Generations 1–10: The fitness score climbs steeply as the algorithm captures initial improvements, such as increases in oxygen content and the assembly of compatible molecular fragments.
- Generations 10–15: The improvement curve flattens, reflecting a period of local exploration where promising variations become less frequent.
- Generation 15+: A noticeable uptick occurs following a successful mutation that introduces a five-membered oxygenated ring. This modification boosts both molecular weight and the O:C ratio, without incurring excessive ring penalties.

By generation 20, as shown in graph 7.1.3, the maximum fitness had increased by 23 percentage points compared to the starting population. This clearly demonstrates effective convergence of the fragment-based genetic algorithm under the applied multi-criteria scoring function, with the system consistently finding molecules that increasingly satisfy fuel-relevant design targets.
-
8.2 Current System Results (Unified Pipeline)

The current repository extends beyond molecular generation to produce actionable blend formulations. Results demonstrate the system's ability to optimize realistic fuel blends under operational constraints.

8.2.1 Blend optimisation outputs (implemented, with real run artefacts)

The repository includes archived blend-optimisation runs in the runs/ directory. Each run stores Top-N results, Portfolio diversity analysis, and a RUN.json with full parameters. The CSV outputs provide comprehensive blend compositions, computed properties, and lab-ready recipes.

8.2.1.1 Top-N.csv outputs

Top-N.csv files contain the highest-scoring blends ranked by their fitness score. Each row includes:
- Scoring metrics: relative_score, score, raw_score, spec_penalty, novel_penalty
- Fuel properties: RON, MON, cetane, LHV (mass and volume), PMI, TSI, OC_ratio, ring_count
- Volatility profile: T10, T50, T90 (°C), RVP (kPa)
- Economics: cost_L, net_cost_L, waste_credit_total, novel_fraction
- Blend composition: components (volume fractions), recipe_mL_1000, recipe_g_1000
- Metadata: theme, restart_id, feasible flag

Example 1 (gasoline, high_ron theme; from runs/20251105_144917_42/Top-2.csv):
- Top blend (score: 47.63, relative_score: 1.132):
  - Composition: isooctane 35%, toluene 30%, MTBE 20%, ethanol 15%
  - Properties: RON 110.8, MON 100.0, PMI 14.4, T10 48.2°C, T90 176.7°C, RVP 41.7 kPa
  - Recipe (per 1000 mL): isooctane 350.0 mL (241.5 g), toluene 300.0 mL (261.0 g), MTBE 200.0 mL (148.0 g), ethanol 150.0 mL (118.5 g)
  - Cost: €1.405/L, feasible: yes, spec_penalty: 0.0
- Second-best blend (score: 47.34, relative_score: 1.125):
  - Composition: isooctane 50%, toluene 30%, MTBE 20%
  - Properties: RON 109.6, MON 101.7, PMI 15.5, T10 47.0°C, T90 174.5°C, RVP 39.5 kPa
  - Recipe: isooctane 500.0 mL (345.0 g), toluene 300.0 mL (261.0 g), MTBE 200.0 mL (148.0 g)
  - Cost: €1.390/L

Example 2 (multi-theme run; from runs/20251030_154613_42/Top-8.csv):
- Top blend (score: 48.05, relative_score: 1.140, theme: high_ron, feasible: yes):
  - Composition: isooctane 34%, toluene 29%, MTBE 22%, ethanol 15%
  - Properties: RON 110.8, MON 100.2, PMI 14.3, T10 48.1°C, T90 175.8°C, RVP 41.9 kPa
  - Recipe (per 1000 mL): isooctane 340.0 mL (234.3 g), toluene 290.0 mL (252.1 g), MTBE 220.0 mL (162.8 g), ethanol 150.0 mL (118.5 g)
  - Cost: €1.402/L, spec_penalty: 0.0
- Second-best blend (score: 47.90, relative_score: 1.137, theme: high_lhv, feasible: yes):
  - Composition: isooctane 36%, toluene 30%, MTBE 18%, kerosene 16%
  - Properties: RON 109.9, MON 99.6, PMI 14.9, T10 50.2°C, T90 180.1°C, RVP 39.0 kPa
  - Recipe: isooctane 360.0 mL (248.4 g), toluene 300.0 mL (261.0 g), MTBE 180.0 mL (133.2 g), kerosene 160.0 mL (136.0 g)
  - Cost: €1.398/L, spec_penalty: 0.0
- Third-best blend (score: -inf, relative_score: -, theme: low_pmi, feasible: no):
  - Composition: isooctane 28%, toluene 12%, diesel 25%, kerosene 20%, MTBE 15%
  - Properties: RON 90.3, MON 81.4, PMI 12.1, T10 60.3°C, T90 222.9°C, RVP 24.2 kPa
  - Recipe: isooctane 280.0 mL (193.0 g), toluene 120.0 mL (104.4 g), diesel 250.0 mL (212.5 g), kerosene 200.0 mL (170.0 g), MTBE 150.0 mL (111.0 g)
  - Cost: €1.476/L, spec_penalty: 10.0
- Remaining blends:
  - Diverse compositions ranging from 3-component blends (e.g., isooctane/toluene/MTBE) to 5-component mixtures (including diesel and kerosene)
  - Feasibility indicated for each: feasible blends with positive scores, infeasible blends marked with -inf (spec violations)
  - Property ranges for feasible blends: RON 109.6-110.8, PMI 14.3-15.5, costs €1.390–1.405/L

8.2.1.2 Portfolio.csv outputs

Portfolio.csv files provide diversity analysis, ranking blends by score while also tracking L1 distance to the best solution. This enables selection of diverse candidate sets for robustness testing.

Example (from runs/20251030_154613_42/Portfolio.csv):
- Rank 1: Best blend (L1_to_best: 0.000) - isooctane/toluene/MTBE/ethanol
- Rank 2: Second-best (L1_to_best: 0.300) - isooctane/toluene/MTBE (no ethanol)
- Rank 3-20: Diverse alternatives with L1 distances ranging from 0.532 to 2.000, showing exploration across composition space
- Portfolio analysis helps identify blends that are compositionally distinct but still high-performing, supporting experimental design for comparative testing

8.2.1.3 Component library CSVs

The repository includes three component library files:

A) components.csv (standard library):
Contains 8 established fuel components with complete property profiles:
- Gasoline fuels: Regular Gasoline (RON 87), Isooctane (RON 100), Toluene (RON 120), MTBE (RON 118), Ethanol (RON 108)
- Diesel fuels: Diesel Fuel (cetane 50), Biodiesel (cetane 55)
- Jet fuels: Kerosene (cetane 45)
Each component includes: SMILES structure, density, LHV, octane/cetane numbers, PMI/TSI, volatility (T10/T50/T90, RVP), cost, and max_vol_frac constraints (e.g., ethanol capped at 15%, MTBE at 20%, biodiesel at 20%)

B) components_novel.csv (novel candidates):
Contains 5 candidate molecules derived from fragment-based generation:
- 2-Methyl-2-butene (CC(C)=CC): RON 95, density 0.65 g/mL, max_vol_frac 5%
- Cyclopentane (C1CCCC1): RON 85, density 0.75 g/mL, max_vol_frac 3%
- 2,3-Dimethylbutane (CC(C)C(C)C): RON 92, density 0.67 g/mL, max_vol_frac 4%
- 1-Hexene (CCCCC=C): RON 90, density 0.67 g/mL, max_vol_frac 5%
- Cyclohexane (C1CCCCC1): RON 83, density 0.78 g/mL, max_vol_frac 3%
These novel components have higher costs (€2.5-3.2/L) and stricter volume fraction caps, reflecting their experimental status.

C) baseline_blend.csv (delta mode reference):
Defines a reference blend for delta-mode optimization:
- Regular Gasoline 80%, Ethanol 10%, MTBE 10%
Used when running optimization with --baseline flag to search for improvements within a constrained L1 budget from this starting point.

8.2.1.4 RUN.json metadata

Each run directory includes RUN.json with complete reproducibility metadata:
- Execution parameters: seed, K (components per blend), top (number of results), restarts, fuel_type, strict_spec flag
- Input configuration: component files used, novel component settings (allow_novel, max_add_novel), preset mode
- Timing: start/finish timestamps, duration_seconds
- Results summary: total_components, novel_components, results_generated
- Specification constraints: T10_min/max, T90_max, RVP_max, RON_min (for gasoline)
- Theme performance: theme_bests (best score per theme), theme_feasible_counts (feasible solutions per theme)
- Machine info: platform, Python version

Example (from runs/20251105_144917_42/RUN.json):
- Run executed: 2025-11-05, duration 156.6 seconds
- Configuration: gasoline fuel, K=7, top=200, 100 restarts, novel components allowed (max 5%)
- Results: 10 total components (5 novel), 2 feasible blends generated
- Best high_ron theme score: 47.63 (isooctane 35%, toluene 30%, MTBE 20%, ethanol 15%)
- All themes (high_ron, low_pmi, high_lhv, low_cost) produced 100 feasible solutions each

This metadata enables complete reproducibility: any run can be recreated by loading the same component CSVs and applying the parameters from RUN.json.

8.2.2 Molecular generation outputs (implemented; results depend on fragment library)

The molecular generator produces ranked candidate SMILES strings along with the fitness score trajectory and per-generation best-candidate descriptors. When running in home-synthesis mode, candidates additionally include synthesis feasibility and route metadata suitable for selecting a shortlist of practically testable molecules.

The generator outputs are typically integrated into the pipeline by converting top candidates to component CSV format (via molecule_to_component.py), which can then be fed into the blend optimiser. The components_novel.csv file demonstrates this workflow: it contains 5 candidate molecules that were generated, scored, and converted to blend-compatible component records.

Each novel component in components_novel.csv includes:
- SMILES structure (canonical representation)
- Estimated fuel properties (RON, density, LHV, volatility proxies)
- Practical constraints (max_vol_frac based on synthesis feasibility and safety)
- Cost estimates (higher than established components, reflecting experimental status)

Because the exact fragment dataset is an input, results are only meaningful when reported with the fragment source and parameters. The system is designed so that experiments can be rerun with the same fragment file and settings to reproduce the candidate shortlist. The unified workflow notebook (notebooks/unified_workflow.ipynb) demonstrates the end-to-end pipeline from fragment loading through molecular generation to blend optimization.


9. Discussion (updated)

Ignition Protocol, in its current form, delivers a practical, reproducible framework for fuel design by coupling:

- a fast, iteration-friendly generator that evolves molecular candidates from fragment libraries, and
- a deterministic, specification-aware blend optimisation engine that outputs lab-ready mixing recipes.

The system assembles molecules rapidly using a fragment-merging approach, enabling broad exploration of chemical space and quick turnaround for candidate generation. Properties of candidate molecules are estimated via streamlined, domain-informed heuristics for key metrics such as RON, MON, cetane number, LHV, PMI, and volatility. These heuristics enable efficient ranking and rapid selection suitable for high-throughput exploration. The workflow integrates molecular generation, property estimation, component conversion, and blend optimisation in a way that supports complete, end-to-end reproducibility. 

Although designed for extensibility, the current setup already supports constrained optimisation (including volume fraction limits and cost) and direct export of novel candidates for further experimentation. This ensures that, even with its fast-and-pragmatic core, Ignition Protocol acts as a concrete “design-to-recipe” engine: it consistently turns high-level search and screening into actionable, spec-compliant blend recipes that can be tested and iterated upon in the lab.


10. Conclusion (updated)

This project delivers a reproducible computational pipeline for fuel discovery and formulation. The repository implements:

- fragment-based candidate generation with fast scoring and practical metadata, and
- deterministic blend optimisation under fuel-type constraints with lab-ready recipes.

The next phase is validation-driven iteration: use the optimiser outputs to run controlled combustion and stability experiments, use those measurements to calibrate or replace surrogate property models, and then close the loop so the engine learns from real data rather than proxy heuristics.


Glossary (updated for the implemented system)

SMILES (Simplified Molecular Input Line Entry System)
Plain-text encoding of molecular structure; used as the canonical representation of candidate molecules.

Fragment library
A file containing SMILES strings used as building blocks for molecule generation.

Fitness function
A numeric score used to rank molecules during evolution. In this repo, compute_fuel_fitness_v3 and home-synthesis variants are used.

Component library (CSV)
The input table for blend optimisation. Each row includes fuel-relevant properties (RON/MON/cetane/LHV/PMI/TSI/volatility proxies/cost) and constraints (max_vol_frac).

max_vol_frac
Maximum allowed volume fraction of a component in a blend; used to enforce manufacturability/safety constraints.

Delta mode (L1 budget)
Optimisation mode that searches near a baseline blend while limiting the L1 deviation from the baseline component fractions.

Top-N / Portfolio outputs
Top-N: best scoring blends; Portfolio: a diverse set of blends to support exploration and robustness.


References

This rewrite preserves the original manuscript’s reference set; see the original project book’s references section for the full bibliography (including GDB-17, evolutionary computation, octane/cetane references, RDKit, and combustion diagnostics sources).


