 
Heavy Stress Profile 
The Heavy Stress profile pushes the engine into very high workload territory, bordering on what a single-machine run can comfortably handle. This profile 
was used to further probe scaling issues and to see if any slowdowns or memory limits would be hit before we reach truly extreme cases. 
Parameterization: We used a similar approach as Light Stress but pushed it further – for instance, 5–10 seeds, and 4 full generations of mutations (and we 
even allowed a 5th generation in some seed branches if computationally feasible). We tried to avoid any manual culling of candidates between generations 
besides the normal filtering; effectively, this was as exhaustive a search as we could manage given the fragment set and generation depth. The fragment 
library and mutation rules remained the same, but by increasing seeds and an extra generation, the potential combinations skyrocket. 
Estimated candidate count: On the order of 10^5. Even with filtering in place, we expected hundreds of thousands of candidates might be generated and 
need processing. A rough theoretical maximum: if one seed lineage without filtering yields ~5^4 (625) molecules by generation 4 (plus preceding gens), 5 
seeds would be 5*625 = 3125 for one branch scenario. But since we allowed possibly a 5th generation in some cases and higher branching, it could be far 
more. We braced for possibly a few hundred thousand molecules. 
Actual candidates processed: The Heavy Stress run ultimately processed around 180,000–200,000 molecules through scoring. The initial raw generation 
was higher (likely over half a million structures considered), but the filters aggressively cut out a large portion. Still, nearly two hundred thousand distinct 
candidates passed through all stages, which is a substantial workload for our Python-based engine. 
Execution time: This profile required tens of minutes to run. On the i7-8700 system, Heavy Stress finished in roughly 1,200 seconds (~20 minutes). On the 
i5-12th Gen system, the runtime was about 900 seconds (15 minutes). The ~5-minute absolute difference is notable, and System B was about 33% faster, 
consistent with the trend of the newer CPU widening the gap under heavier loads. During these runs, we observed near 100% CPU utilization on all cores 
for sustained periods, especially in the core generation and scoring loops. Both systems handled the load without crashing, but this test starts to reveal the 
engine’s upper efficiency limits on a single machine. 
The top 8 molecules from the Heavy Stress profile are presented below. By now, the highest-scoring candidates are likely hitting the ceiling of what the 
surrogate score allows – meaning these molecules very closely match the ideal characteristics encoded in our scoring function. They may be quite complex 
(though still within the realm of chemically plausible fuel molecules thanks to the filters). It’s interesting to see that as we increase search effort, the top 
scores have gradually risen (compare, for example, top scores in Demo vs Light vs Heavy). This is expected because a larger search is more likely to find 
that rare combination of features that maximizes the score. However, these high-scoring molecules might also be more unusual or on the fringe of the 
chemical space we’d consider; they are useful to note, but we would treat them with caution in terms of real-world viability pending further analysis. 
Heavy Stress Profile Top 8 Molecules: 
Rank  Molecule (SMILES)                                   Score 
1     CC(C)(C(O)C(C)C=C(C)C)C(C)(C)COC                   0.97  
2     C=C(C)C(C)(C(O)C(C)C(C)C)C(C)C(C)C                 0.96  
3     CC1(C)C(C)C(CO)C(C)(C)C(C)C1(C)C                   0.95  
4     CC(C)(C)C(C)C(COC(C)C)C(C)=C(C)C                   0.95  
5     C=C(C)C(C)(COC)C(C)(C)C(C)C(C)C                    0.94  
6     CC(C)(C(O)C)C(C)(C)C=CC(C)(C)COC                   0.94  
7     CC1(C)CC(C)(C)C(C)(C(O)C)C(C)C1C                   0.93  
8     C=C(C)C(C)(C)C(C)C(O)C(C)(C)C(C)C                  0.93  
18 
